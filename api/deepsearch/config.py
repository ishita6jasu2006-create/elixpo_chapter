get_youtube_video_metadata_show_log = False
MAX_TRANSCRIPT_WORD_COUNT = 3000
MAX_TOTAL_SCRAPE_WORD_COUNT = 8000
MAX_IMAGES_TO_INCLUDE = 4
scrape_website_show_log = True
SCRAPE_IMAGE=True
MAX_LINKS_TO_TAKE = 10
isHeadless=True
POLLINATIONS_ENDPOINT = "https://enter.pollinations.ai/api/generate/v1/chat/completions"
BASE_CACHE_DIR = "./cached_audio"
AUDIO_TRANSCRIBE_SIZE="small"  
transcription = """How do you all do? We have learned before how to define a simple trait in Rust. Now we learn how to use traits as restrictions for generic functions. To start, I will show you how to use trait limits for parameters. We have two forms for this. One, which is the short form and one, which simply represents explicit generic functions with limits. So let's start with the implementation of the short form syntax. We use the same trait from the previous lesson, namely summary, which has a function called Summary. Directly below we can enter public function notify. Here we want to give an element. To do this, we use the syntax, the implement syntax. So we want to implement this trait here. Directly below we then assume that there are current messages. To do this, we use the method from Summary for this element. It is important that we define this element so that the trait summary is implemented. Otherwise it does not work. Next, we use the explicit generic syntax, which represents the long form. So let's enter public function notify. Since this is the long form, I simply add it. Here we define a generic type called t, which implements the remark Summary. The element is a reference to t. With this generic type with the restriction Summary, we can enter item and determine that it is a reference to t. Here we can then add exactly the same code cells. Both work the same. The use of multiple parameters is also quite simple. We just have to define and define element 1 and element 2, that both Summary implement. In the long form, this is possible even more practical, since we can use the same generic type for both elements. This use, it creates a structure, implements the summary. This looks like this. Here we have a structure called block attribute, which contains a title and a author. Then we implement the summary for the block attribute here. And here exactly everyone of us will be created block attribute to a compatible parameter or argument for all our notification functions. In mine, we now create two different structures, which are called post1 and the other post2. With these block attributes, we can add, update and give an attribute, or it has to be a reference to a attribute. Like zb, attribute 1. And that will work wonderfully. As you can see, the following is shown when executing. Breaking news, Rust Traits by Alice and the other functions work just as well. If we use the long form, we only have to give a reference to a structure, which the Merckmal summary implement. And for functions, we only have to give several compatible elements, like zb, attribute 1 and attribute 2. We only follow the signature here, which we have defined in our function. Next, I want to show you how you can combine multiple Merckmal limits with the help of the plus operators. Sometimes you need a guy to implement multiple Merckmal and use methods from all. With the plus operator, we can achieve this. In any case, we want to use the Merckmal, summary and display on this element. First, we have to import the Merckmal display from the standard library and set it in the name of the object. Then we can give summary plus display. This is why this element has to implement both the Merckmal, summary and the Merckmal display. Since this also requires the Merckmal, display, we can now give it out normally. If we want to do this with the help of generica, we can do it very simply by adding the plus operator to the genericum. Then everything else works as usual. To use this, we create an article and implement the Merckmal, summary for the article. In addition, we have to return to the import and use the format from the standard library. The reason for this is that we also have to implement the display trade for the article. Here we define how we want to format the display trades with the help of the display. Then we can directly create an article in mine, which is called Charlie, under standing trades. Then we can use NotifyPass in an article and export the code. This is the output we get. If we now use the generic version, we get a syntax error, since I've executed this in Python. If we execute this in Rust, we should get exactly the same output, since both approaches are practically identical."""